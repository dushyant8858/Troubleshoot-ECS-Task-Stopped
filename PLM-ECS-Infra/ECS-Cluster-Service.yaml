# aws cloudformation create-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM-ECS Key=auto-delete,Value=no --stack-name PLM-ECS
# aws cloudformation update-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM-ECS Key=auto-delete,Value=no --stack-name PLM-ECS

# aws cloudformation create-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --parameters ParameterKey=HostedZoneId,ParameterValue=Z38JIISUVMYB2F ParameterKey=HostedZoneName,ParameterValue=dubaria.myinstance.com ParameterKey=ImageUrl,ParameterValue=dushyant8858/FrontEndDateTime:local ParameterKey=ContainerPort,ParameterValue=8084 ParameterKey=BackEndGreetingImageUrl,ParameterValue=dushyant8858/nodejs-hello-world:DD ParameterKey=KeyPair,ParameterValue=us-west-2 --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM Key=MinorCost,Value=PLM-ECS --stack-name PLM-ECS
# aws cloudformation update-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --parameters ParameterKey=HostedZoneId,ParameterValue=Z38JIISUVMYB2F ParameterKey=HostedZoneName,ParameterValue=dubaria.myinstance.com ParameterKey=ImageUrl,ParameterValue=dushyant8858/FrontEndDateTime:local ParameterKey=ContainerPort,ParameterValue=8084 ParameterKey=BackEndGreetingImageUrl,ParameterValue=dushyant8858/nodejs-hello-world:DD ParameterKey=KeyPair,ParameterValue=us-west-2 --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM Key=MinorCost,Value=PLM-ECS --stack-name PLM-ECS

# while true ; do aws cloudformation describe-stacks --region us-west-2 --stack-name PLM-VPC --query Stacks[].StackStatus && sleep 5; done

# aws cloudformation delete-stack --region us-west-2 --stack-name PLM-ECS

################################################################################################################

AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy a service on AWS Fargate, hosted in a private subnet, but accessible via a public load balancer.
Parameters:
  EnvironmentName:
    Type: String
    Default: PLM
    Description: The name of the environment to add this service to

# FrontEndDateTime = DateTim
# FrontEndDateTime Service Parameters 
  FrontEndDateTimeServiceName:
    Type: String
    Default: FrontEndDateTime
    Description: PLM FrontEndDateTime service
  FrontEndDateTimeImageUrl:
    Type: String
    Default: nginx:latest
    Description: The url of a docker image that contains the FrontEndDateTime application process that will handle the traffic for this service
  FrontEndDateTimeECRRepositoryName:
    Type: String
    Default: 'PLM-FrontEndDateTime'
    Description: ECR repository Name that you need to create for FrontEndDateTime images 
  FrontEndDateTimeContainerPort:
    Type: Number
    Default: 80
    # Default: '8083'
    Description: What port number the application inside the docker container is binding to
  FrontEndDateTimeContainerCpu:
    Type: Number
    Default: 256
    # Default: 1024    
    Description: How much CPU to give the container. 1024 is 1 CPU
  FrontEndDateTimeContainerMemory:
    Type: Number
    Default: 512
    # Default: 4096
    Description: How much memory in megabytes to give the 
  FrontEndDateTimeDesiredCount:
    Type: Number
    Default: 0
    Description: How many copies of the service task to run

# BackEndGreeting = BackEndGreeting
# BackEndGreeting Service Parameters 
  BackEndGreetingServiceName:
    Type: String
    Default: BackEndGreeting
    Description: PLM BackEndGreeting service
  BackEndGreetingImageUrl:
    Type: String
    Default: httpd:latest
    Description: The url of a docker image that contains the  application process that will handle the traffic for this service
  BackEndGreetingECRRepositoryName:
    Type: String
    Default: nginx
    Description: ECR repository Name that you need to create for  images 
  BackEndGreetingContainerPort:
    Type: Number
    Default: '8084'
    # Default: '80'
    Description: What port number the application inside the docker container is binding to
  BackEndGreetingContainerCpu:
    Type: Number
    Default: 256
    # Default: 1024    
    Description: How much CPU to give the container. 1024 is 1 CPU
  BackEndGreetingContainerMemory:
    Type: Number
    Default: 512
    # Default: 4096
    Description: How much memory in megabytes to give the 
  BackEndGreetingDesiredCount:
    Type: Number
    Default: 0
    Description: How many copies of the service task to run

# ALB Parameters 
  Path:
    Type: String
    Default: "*"
    Description: A path on the load balancer that this service should be connected to. Use * to send all load balancer traffic to this service.
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer. This only applies if your have multiple services which have been assigned to different paths on the load balancer.
  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the service's containers if the code within needs to access other AWS resources like S3 buckets, DynamoDB tables, etc

  HostedZoneId:
    Description: HostedZone ID
    Type: String
    Default: 'Z38JIISUVMYB2F'
  HostedZoneName:
    Description: HostedZone Name
    Type: String
    Default: 'dubaria.myinstance.com'
  PLMPublicLoadBalancerSubDomainNameWithDot:
    Description: 'Name that is used to create the DNS entry with trailing dot, e.g. ${SubDomainNameWithDot}${HostedZoneName}. Leave blank for naked (or apex and bare) domain. Requires ParentZoneStack parameter!'
    Type: String
    Default: '.'

# DomainBackEndGreetingPrivateServiceDiscoveryNamespace
  DomainBackEndGreetingPrivateServiceDiscoveryNamespace:
    Type: String
    Default: BackEndGreeting
    Description: The name of the namespace. Services are prepended, for example user.service.production

# ASG / AutoScaling Parameters
  # KeyPair:
  #   Description: Name of key pair to use for SSH access to the instances
  #   Type: 'AWS::EC2::KeyPair::KeyName'
  #   ConstraintDescription: Key pair must already exist in the region of the stack creation
  #   Default: dd-us-west-2
  InstanceType:
    Description: Type of EC2 instance to use
    Type: String
    AllowedValues:
      - t2.micro
    ConstraintDescription: Must be a size from t2 instance families
    Default: t2.micro

Mappings:
  InstanceArchMap:
    t2.micro:
      Arch: X8664
  RegionAmiMap:
    us-west-2:
      # aws ssm get-parameters --names /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id --region us-west-2 --query Parameters[].Value --output text
      X8664: ami-0a4cbf3bd47ef1bc9


Conditions:
  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]

Resources:
# ECS Resources
  PLMEcsCluster:
    Type: AWS::ECS::Cluster

  # Public load balancer, hosted in public subnets that is accessible to the public, and is intended to route traffic to one or more public facing services. This is used for accepting traffic from the public internet and directing it to public facing microservices
  PLMPublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access to ALB from anywhere on the internet to FrontEndDateTime ECS Service 
          - CidrIp: 0.0.0.0/0
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref FrontEndDateTimeContainerPort
            ToPort: !Ref FrontEndDateTimeContainerPort
            Description: Allow access to ALB from anywhere on the internet to FrontEndDateTime ECS Service
          # Allow access to ALB from anywhere on the internet to BackEndGreeting ECS Service
          - CidrIp: 0.0.0.0/0
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndGreetingContainerPort
            ToPort: !Ref BackEndGreetingContainerPort
            Description: Allow access to ALB from anywhere on the internet to BackEndGreeting ECS Service

  PLMPublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic from the internet can reach the load balancer directly via the internet gateway
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetOne
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetTwo
      SecurityGroups: [!Ref 'PLMPublicLoadBalancerSG']

  PLMPublicLoadBalancerRecordSet:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub
        - '${PLMPublicLoadBalancerSubDomainNameWithDot}${HostedZoneName}'
        - SubDomainNameWithDot: !Ref PLMPublicLoadBalancerSubDomainNameWithDot
          HostedZoneName: !Ref HostedZoneName
      ResourceRecords:
        - !GetAtt 'PLMPublicLoadBalancer.DNSName'
      TTL: 300
      Type: CNAME

  BackEndGreetingPrivateServiceDiscoveryNamespace:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties:
      Name: !Ref DomainBackEndGreetingPrivateServiceDiscoveryNamespace
      # Name: !Ref BackEndGreetingServiceName
      Vpc:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId

###################
# ASG resources
###################
  ECSInstanceProfileRole:
    Type: AWS::IAM::InstanceProfile
    Properties: 
      Roles: 
        - !Ref ECSInstanceRole
  ECSInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
  PLMEcsLaunchTemplate:
    Type: 'AWS::EC2::LaunchTemplate'
    Metadata:
      'AWS::CloudFormation::Init':
        configSets:
          base_setup:
            - cfn_hup
            - ecs_configure
            - install_pkgs
            - enable_sysstat
        cfn_hup:
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Join 
                - ''
                - - |
                    [main]
                  - stack=
                  - !Ref 'AWS::StackId'
                  - |+

                  - region=
                  - !Ref 'AWS::Region'
                  - |+

                  - |
                    interval=5
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Join 
                - ''
                - - |
                    [cfn-auto-reloader-hook]
                  - |
                    triggers=post.update
                  - >
                    path=Resources.PLMEcsLaunchTemplate.Metadata.AWS::CloudFormation::Init
                  - 'action=/opt/aws/bin/cfn-init -v '
                  - '   --stack '
                  - !Ref 'AWS::StackName'
                  - '   --resource PLMEcsLaunchTemplate '
                  - '   --configsets base_setup '
                  - '   --region '
                  - !Ref 'AWS::Region'
                  - |+

                  - |
                    runas=root
              mode: '000400'
              owner: root
              group: root
          services:
            sysvinit:
              cfn-hup:
                enabled: 'true'
                ensureRunning: 'true'
                files:
                  - /etc/cfn/cfn-hup.conf
                  - /etc/cfn/hooks.d/cfn-auto-reloader.conf
        ecs_configure:
          files:
            /etc/ecs/ecs.config:
              content: !Join 
                - ''
                - - 'ECS_CLUSTER='
                  - !Ref 'PLMEcsCluster'
                  - |+

                  - >
                    ECS_AVAILABLE_LOGGING_DRIVERS=["json-file","awslogs","journald","logentries","syslog"]
                  - |
                    ECS_ENABLE_TASK_IAM_ROLE=true
                  - |
                    ECS_RESERVED_MEMORY=64
          services:
            sysvinit:
              cfn-hup:
                enabled: 'true'
                ensureRunning: 'true'
        install_pkgs:
          packages:
            yum:
              sysstat: []
              awscli: []
              bind-utils: []
        enable_sysstat:
          services:
            sysvinit:
              sysstat:
                enabled: 'true'
                ensureRunning: 'true'
    Properties:
      LaunchTemplateData:
        InstanceType: !Ref InstanceType
        ImageId: !FindInMap 
          - RegionAmiMap
          - !Ref 'AWS::Region'
          - !FindInMap 
            - InstanceArchMap
            - !Ref InstanceType
            - Arch
        # KeyName: !Ref KeyPair
        SecurityGroupIds:
          # - !Ref ContainerSecurityGroup
          - !Ref FrontEndDateTimeContainerSecurityGroup
          - !Ref BackEndGreetingContainerSecurityGroup
          # - !Ref NishitDushyantPLMEcsInstanceSecurityGroup
        IamInstanceProfile: 
          Name: !Ref ECSInstanceProfileRole
        UserData: !Base64 
          'Fn::Join':
            - ''
            - - |
                #!/bin/bash -xe
              - |
                yum update -y 
              - |
                yum install aws-cfn-bootstrap -y 
              - '/opt/aws/bin/cfn-init -v '
              - '   --stack '
              - !Ref 'AWS::StackId'
              - '   --resource PLMEcsLaunchTemplate '
              - '   --configsets base_setup '
              - '   --region '
              - !Ref 'AWS::Region'
              - |+

              - '/opt/aws/bin/cfn-signal -e $? '
              - '   --stack '
              - !Ref 'AWS::StackId'
              - '   --resource PLMEcsASG '
              - '   --region '
              - !Ref 'AWS::Region'
              - |+

        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${AWS::StackName}-PLMEcsASG'
  PLMEcsASG:
    Type: 'AWS::AutoScaling::AutoScalingGroup'
    DependsOn: PLMEcsCluster
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref PLMEcsLaunchTemplate
        Version: !GetAtt 
          - PLMEcsLaunchTemplate
          - LatestVersionNumber
      VPCZoneIdentifier:
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetOne
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetTwo
      MinSize: '3'
      MaxSize: '4'
      DesiredCapacity: '3'
      # NewInstancesProtectedFromScaleIn: true
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: '3'
        WaitOnResourceSignals: true
        PauseTime: PT5M
    CreationPolicy:
      ResourceSignal:
        Count: '1'
        Timeout: PT5M

  # PLMEcsInstanceSecurityGroup:
  #   Type: 'AWS::EC2::SecurityGroup'
  #   Properties:
  #     GroupDescription: Nishit Dushyant ECS Instance Security Group
  #     VpcId: {'Fn::ImportValue': !Sub '${EnvironmentName}:VpcId'}
  #     # SecurityGroupIngress:
  #     #   - Description: Allow traffic from [NISHITs Home to PLM ECS Instance]
  #     #     IpProtocol: tcp
  #     #     FromPort: 22
  #     #     ToPort: 22
  #     #     # CidrIp: !Join ['' , [{'Fn::ImportValue': !Sub '${EnvironmentName}:NatGatewayOneAttachment'} , '/32' ] ]
  #     #     # http://checkip.amazonaws.com/
  #     #     CidrIp: !Join ['' , ['71.150.221.250' , '/32' ] ]
  #     #   - Description: Allow traffic from [Dushyants Home to PLM ECS Instance]
  #     #     IpProtocol: tcp
  #     #     FromPort: 22
  #     #     ToPort: 22
  #     #     CidrIp: !Join ['' , ['74.141.7.117' , '/32' ] ]
  #     # Tags: 
  #     #   - Key: Name
  #     #     Value: DUSHYANT ECS Instance SSH


####################
# FrontEndDateTime resources
####################
  # A security group for the containers we will run in Fargate. Rules are added to this security group based on what ingress you add for the cluster.
  FrontEndDateTimeContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate FrontEndDateTime containers
      # VpcId: !Ref 'VPC' Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      VpcId: 
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access ONLY from ALB 
          - SourceSecurityGroupId: !Ref PLMPublicLoadBalancerSG
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref FrontEndDateTimeContainerPort
            ToPort: !Ref FrontEndDateTimeContainerPort
            Description: !Sub Allow access ONLY from ALB:${PLMPublicLoadBalancer.LoadBalancerName} on Port:${FrontEndDateTimeContainerPort}

  # This is a role which is used by the ECS tasks themselves.
  FrontEndDateTimeECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        # - arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess
      Policies:
        - PolicyName: FrontEndDateTimeECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Allow the ECS Tasks to download images from ECR
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'

                # Allow the ECS tasks to upload logs to CloudWatch
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
              Resource: '*'
  FrontEndDateTimeECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        # - arn:aws:iam::aws:policy/AmazonS3FullAccess
      # Policies:
      #   - PolicyName: FrontEndDateTimeECSTaskRolePolicy
      #     PolicyDocument:
      #       Statement:
      #       - Effect: Allow
      #         Action:
      #           # Allow the ECS Tasks to only Read from S3
      #           - 's3:Get*'
      #           - 's3:List*'
      #           # Allow the ECS tasks to get Secrets from SSM
      #           - 'ssm:Describe*'
      #           - 'ssm:Get*'
      #           - 'ssm:List*'
      #         Resource: '*'

  # A log group for storing the stdout logs from this service's containers
  FrontEndDateTimeLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-ECSservice-${FrontEndDateTimeServiceName}
      RetentionInDays: 7

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  FrontEndDateTimeTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'FrontEndDateTimeServiceName'
      Cpu: !Ref 'FrontEndDateTimeContainerCpu'
      Memory: !Ref 'FrontEndDateTimeContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
        - EC2
      ExecutionRoleArn: !GetAtt 'FrontEndDateTimeECSTaskExecutionRole.Arn'
      TaskRoleArn: !GetAtt 'FrontEndDateTimeECSTaskRole.Arn'
      ContainerDefinitions:
        - Name: !Ref 'FrontEndDateTimeServiceName'
          Cpu: !Ref 'FrontEndDateTimeContainerCpu'
          Memory: !Ref 'FrontEndDateTimeContainerMemory'
          Image: !Ref 'FrontEndDateTimeImageUrl'
          # Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${FrontEndDateTimeECRRepositoryName}:latest
          PortMappings:
            - ContainerPort: !Ref 'FrontEndDateTimeContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-ECSservice-${FrontEndDateTimeServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'FrontEndDateTimeServiceName'

  # The service. The service is a resource which allows you to run multiple copies of a type of task, and gather up their logs and metrics, as well as monitor the number of running tasks and replace any that have crashed
  FrontEndDateTimeECSService:
    Type: AWS::ECS::Service
    DependsOn: 
      - BackEndGreetingECSService
      - FrontEndDateTimeLoadBalancerRule
    Properties:
      # ServiceName: !Ref 'FrontEndDateTimeServiceName'
      Cluster: !Ref PLMEcsCluster
      LaunchType: FARGATE
      PlatformVersion: 1.4.0
      HealthCheckGracePeriodSeconds: '180'
      DeploymentConfiguration:
        MaximumPercent: '200'
        MinimumHealthyPercent: '100'
      DesiredCount: !Ref FrontEndDateTimeDesiredCount
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups: 
            - !Ref FrontEndDateTimeContainerSecurityGroup
          Subnets:
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetOne
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetTwo
      TaskDefinition: !Ref 'FrontEndDateTimeTaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'FrontEndDateTimeServiceName'
          ContainerPort: !Ref FrontEndDateTimeContainerPort
          TargetGroupArn: !Ref 'FrontEndDateTimeTargetGroup'

  # A target group. This is used for keeping track of all the tasks, and what IP addresses / port numbers they have. You can query it yourself, to use the addresses yourself, but most often this target group is just connected to an application load balancer, or network load balancer, so it can automatically distribute traffic across all the targets.
  FrontEndDateTimeTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /currentFrontEndDateTime
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 4
      TargetType: ip
      # Name: !Ref 'FrontEndDateTimeServiceName'
      Port: !Ref 'FrontEndDateTimeContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 10

  FrontEndDateTimePublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: PLMPublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'FrontEndDateTimeTargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PLMPublicLoadBalancer'
      Port: !Ref FrontEndDateTimeContainerPort
      Protocol: HTTP

  # Create a rule on the load balancer for routing traffic to the target group
  FrontEndDateTimeLoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'FrontEndDateTimeTargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn: !Ref FrontEndDateTimePublicLoadBalancerListener
      Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  FrontEndDateTimeScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: FrontEndDateTimeECSService
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId: !Join [ '/' , [ 'service' , !Ref 'PLMEcsCluster' , !GetAtt 'FrontEndDateTimeECSService.Name' ] ] 
      MinCapacity: 1
      MaxCapacity: 2
      RoleARN: !Sub 'arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService'

  # Create Track scaling policies for the FrontEndDateTime service
  FrontEndDateTimeTargetTrackingScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: 
      - FrontEndDateTimeLoadBalancerRule
      - FrontEndDateTimeECSService
      - FrontEndDateTimeScalableTarget
    Properties:
      PolicyName: !Join [ '/' , [ 'scale' , !Ref 'EnvironmentName' , !GetAtt 'FrontEndDateTimeECSService.Name' ] ]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref FrontEndDateTimeScalableTarget
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 100.00
        ScaleInCooldown: 120
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageMemoryUtilization

#################### 
# BackEndGreeting resources
#################### 
  # A security group for the containers we will run in Fargate. Rules are added to this security group based on what ingress you add for the cluster.
  BackEndGreetingContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate BackEndGreeting containers
      VpcId: 
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access ONLY from ALB from anywhere on the internet
          - SourceSecurityGroupId: !Ref PLMPublicLoadBalancerSG
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndGreetingContainerPort
            ToPort: !Ref BackEndGreetingContainerPort
            Description: !Sub Allow access ONLY from ALB:${PLMPublicLoadBalancer.LoadBalancerName} on BackEndGreetingContainerPort:${BackEndGreetingContainerPort}
          # Allow access ONLY from ALB from anywhere on the internet
          - SourceSecurityGroupId: !Ref FrontEndDateTimeContainerSecurityGroup
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndGreetingContainerPort
            ToPort: !Ref BackEndGreetingContainerPort
            Description: !Sub Allow access ONLY from FrontEndDateTimeContainerSecurityGroup:${FrontEndDateTimeContainerSecurityGroup} on BackEndGreetingContainerPort:${BackEndGreetingContainerPort}

  # This is a role which is used by the ECS tasks themselves.
  BackEndGreetingECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        # - arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess
      Policies:
        - PolicyName: BackEndGreetingAmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Allow the ECS Tasks to download images from ECR
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'

                # Allow the ECS tasks to upload logs to CloudWatch
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
              Resource: '*'

  BackEndGreetingECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        # - arn:aws:iam::aws:policy/AmazonS3FullAccess
      # Policies:
      #   - PolicyName: FrontEndDateTimeECSTaskRolePolicy
      #     PolicyDocument:
      #       Statement:
      #       - Effect: Allow
      #         Action:
      #           # Allow the ECS Tasks to only Read from S3
      #           - 's3:Get*'
      #           - 's3:List*'
      #           # Allow the ECS tasks to get Secrets from SSM
      #           - 'ssm:Describe*'
      #           - 'ssm:Get*'
      #           - 'ssm:List*'
      #         Resource: '*'


  # A log group for storing the stdout logs from this service's containers
  BackEndGreetingLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-ECSservice-${BackEndGreetingServiceName}
      RetentionInDays: 7

  # The task definition. This is a simple metadata description of what container to run, and what resource requirements it has.
  BackEndGreetingTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'BackEndGreetingServiceName'
      Cpu: !Ref 'BackEndGreetingContainerCpu'
      Memory: !Ref 'BackEndGreetingContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'BackEndGreetingECSTaskRole.Arn'
      ExecutionRoleArn: !GetAtt 'BackEndGreetingECSTaskExecutionRole.Arn'
      ContainerDefinitions:
        - Name: !Ref 'BackEndGreetingServiceName'
          Cpu: !Ref 'BackEndGreetingContainerCpu'
          Memory: !Ref 'BackEndGreetingContainerMemory'
          # Image: !Ref 'BackEndGreetingImageUrl'
          Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${BackEndGreetingECRRepositoryName}:latest
          PortMappings:
            - ContainerPort: !Ref 'BackEndGreetingContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-ECSservice-${BackEndGreetingServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'BackEndGreetingServiceName'

  # The service. The service is a resource which allows you to run multiple copies of a type of task, and gather up their logs and metrics, as well as monitor the number of running tasks and replace any that have crashed
  BackEndGreetingECSService:
    Type: AWS::ECS::Service
    DependsOn: BackEndGreetingLoadBalancerRule
    Properties:
      # ServiceName: !Ref 'BackEndGreetingServiceName'
      # Cluster:
      #   Fn::ImportValue: !Sub ${EnvironmentName}:PLMEcsCluster
      Cluster: !Ref PLMEcsCluster
      LaunchType: FARGATE
      PlatformVersion: 1.4.0
      HealthCheckGracePeriodSeconds: '180'
      DeploymentConfiguration:
        MaximumPercent: '200'
        MinimumHealthyPercent: '100'
      DesiredCount: !Ref BackEndGreetingDesiredCount
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups: 
            - !Ref BackEndGreetingContainerSecurityGroup
          Subnets:
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetOne
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetTwo
      TaskDefinition: !Ref 'BackEndGreetingTaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'BackEndGreetingServiceName'
          ContainerPort: !Ref BackEndGreetingContainerPort
          TargetGroupArn: !Ref 'BackEndGreetingTargetGroup'
      ServiceRegistries:
        - RegistryArn: !GetAtt BackEndGreetingServiceDiscoveryService.Arn
          # ContainerPort: !Ref 'BackEndGreetingContainerPort'
          # ContainerName: !Ref 'BackEndGreetingServiceName'

  # Create a service discovery service in the private service namespace.
  BackEndGreetingServiceDiscoveryService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: !Ref BackEndGreetingServiceName
      DnsConfig:
        DnsRecords: [{Type: A, TTL: "30"}]
        NamespaceId: !Ref BackEndGreetingPrivateServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  # A target group. This is used for keeping track of all the tasks, and what IP addresses / port numbers they have. You can query it yourself, to use the addresses yourself, but most often this target group is just connected to an application load balancer, or network load balancer, so it can automatically divstribute traffic across all the targets.
  BackEndGreetingTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /BackEndGreeting
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 4
      TargetType: ip
      # Name: !Ref 'BackEndGreetingServiceName'
      Port: !Ref 'BackEndGreetingContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 10

  BackEndGreetingPublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: PLMPublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'BackEndGreetingTargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PLMPublicLoadBalancer'
      Port: !Ref BackEndGreetingContainerPort
      Protocol: HTTP

  # Create a rule on the load balancer for routing traffic to the target group
  BackEndGreetingLoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'BackEndGreetingTargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      # ListenerArn:
      #   Fn::ImportValue: !Sub ${EnvironmentName}:PublicListener
      ListenerArn: !Ref BackEndGreetingPublicLoadBalancerListener
      Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  BackEndGreetingScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: BackEndGreetingECSService
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId: !Join [ '/' , [ 'service' , !Ref 'PLMEcsCluster' , !GetAtt 'BackEndGreetingECSService.Name' ] ] 
      MinCapacity: 1
      MaxCapacity: 2
      RoleARN: !Sub 'arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService'

  # Create Target Tracking scaling policies for the BackEndGreeting service
  BackEndGreetingTargetTrackingScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: 
      - BackEndGreetingLoadBalancerRule
      - BackEndGreetingECSService
      - BackEndGreetingScalableTarget
    Properties:
      PolicyName: !Join [ '/' , [ 'scale' , !Ref 'EnvironmentName' , !GetAtt 'BackEndGreetingECSService.Name' ] ]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref BackEndGreetingScalableTarget
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 100.00
        ScaleInCooldown: 120
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageMemoryUtilization


# These are the values output by the CloudFormation template. Be careful about changing any of them, because of them are exported with specific names so that the other task related CF templates can use them.
Outputs:
  PLMEcsCluster:
    Description: The name of the ECS cluster
    Value: !Ref 'PLMEcsCluster'
    Export:
      Name: !Sub ${EnvironmentName}:PLMEcsCluster

  # FrontEndDateTime
  FrontEndDateTimeECSTaskExecutionRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'FrontEndDateTimeECSTaskExecutionRole.Arn'
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndDateTimeECSTaskExecutionRole
  FrontEndDateTimeContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref 'FrontEndDateTimeContainerSecurityGroup'
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndDateTimeContainerSecurityGroup
  FrontEndDateTimePublicLoadBalancerListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref FrontEndDateTimePublicLoadBalancerListener
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndDateTimePublicLoadBalancerListener
  FrontEndDateTimeExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${FrontEndDateTimeContainerPort}/currentFrontEndDateTime
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndDateTimeExternalUrl

  # BackEndGreeting
  BackEndGreetingECSTaskExecutionRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'BackEndGreetingECSTaskExecutionRole.Arn'
    Export:
      Name: !Sub ${EnvironmentName}:BackEndGreetingECSTaskExecutionRole
  BackEndGreetingContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref 'BackEndGreetingContainerSecurityGroup'
    Export:
      Name: !Sub ${EnvironmentName}:BackEndGreetingContainerSecurityGroup
  BackEndGreetingPublicLoadBalancerListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref BackEndGreetingPublicLoadBalancerListener
    Export:
      Name: !Sub ${EnvironmentName}:BackEndGreetingPublicLoadBalancerListener
  BackEndGreetingExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${BackEndGreetingContainerPort}/BackEndGreeting
    Export:
      Name: !Sub ${EnvironmentName}:BackEndGreetingExternalUrl
  BackEndGreetingPrivateServiceDiscoveryNamespace:
    Description: The ID of the private service discovery namespace
    Value: !Ref BackEndGreetingPrivateServiceDiscoveryNamespace
    Export:
      Name: !Sub ${EnvironmentName}:BackEndGreetingPrivateServiceDiscoveryNamespace
  
  # FrontEndDateTimeBackEndGreeting
  FrontEndDateTimeBackEndGreetingExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${FrontEndDateTimeContainerPort}/currentFrontEndDateTime/BackEndGreeting
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndDateTimeBackEndGreetingExternalUrl
