# aws cloudformation create-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM-ECS Key=auto-delete,Value=no --stack-name PLM-ECS
# aws cloudformation update-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM-ECS Key=auto-delete,Value=no --stack-name PLM-ECS

# aws cloudformation create-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --parameters ParameterKey=HostedZoneId,ParameterValue=Z38JIISUVMYB2F ParameterKey=HostedZoneName,ParameterValue=dubaria.myinstance.com ParameterKey=ImageUrl,ParameterValue=dushyant8858/FrontEnd:local ParameterKey=ContainerPort,ParameterValue=8084 ParameterKey=BackEndImageUrl,ParameterValue=dushyant8858/nodejs-hello-world:DD ParameterKey=KeyPair,ParameterValue=us-west-2 --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM Key=MinorCost,Value=PLM-ECS --stack-name PLM-ECS
# aws cloudformation update-stack --template-body file:///Users/dubaria/Desktop/Exercises/ECS/Troubleshoot-ECS-Task-Stopped/ECS-Cluster-Service.yaml --parameters ParameterKey=HostedZoneId,ParameterValue=Z38JIISUVMYB2F ParameterKey=HostedZoneName,ParameterValue=dubaria.myinstance.com ParameterKey=ImageUrl,ParameterValue=dushyant8858/FrontEnd:local ParameterKey=ContainerPort,ParameterValue=8084 ParameterKey=BackEndImageUrl,ParameterValue=dushyant8858/nodejs-hello-world:DD ParameterKey=KeyPair,ParameterValue=us-west-2 --capabilities CAPABILITY_IAM --region us-west-2 --tags Key=Cost,Value=PLM Key=MinorCost,Value=PLM-ECS --stack-name PLM-ECS

# while true ; do aws cloudformation describe-stacks --region us-west-2 --stack-name PLM-VPC --query Stacks[].StackStatus && sleep 5; done

# aws cloudformation delete-stack --region us-west-2 --stack-name PLM-ECS

################################################################################################################

AWSTemplateFormatVersion: '2010-09-09'
Description: Deploy a service on AWS Fargate, hosted in a private subnet, but accessible via a public load balancer.
Parameters:
  EnvironmentName:
    Type: String
    Default: PLM
    Description: The name of the environment to add this service to

# FrontEnd = DateTim
# FrontEnd Service Parameters 
  FrontEndServiceName:
    Type: String
    Default: FrontEnd
    Description: PLM FrontEnd service
  FrontEndImageUrl:
    Type: String
    Default: 8xxxxxxxxxxx0.dkr.ecr.us-west-2.amazonaws.com/PLM-FrontEnd:aws-cfn-PLM
    Description: The url of a docker image that contains the FrontEnd application process that will handle the traffic for this service
  FrontEndECRRepositoryName:
    Type: String
    Default: 'PLM-FrontEnd'
    Description: ECR repository Name that you need to create for FrontEnd images 
  FrontEndContainerPort:
    Type: Number
    Default: '8083'
    Description: What port number the application inside the docker container is binding to
  FrontEndContainerCpu:
    Type: Number
    Default: 992
    # Default: 1024    
    Description: How much CPU to give the container. 1024 is 1 CPU
  FrontEndContainerMemory:
    Type: Number
    Default: 887
    # Default: 4096
    Description: How much memory in megabytes to give the 
  FrontEndDesiredCount:
    Type: Number
    Default: 0
    Description: How many copies of the service task to run

# BackEnd = BackEnd
# BackEnd Service Parameters 
  BackEndServiceName:
    Type: String
    Default: BackEnd
    Description: PLM service
  BackEndImageUrl:
    Type: String
    Default: 8xxxxxxxxxxx0.dkr.ecr.us-west-2.amazonaws.com/PLM-:aws-cfn-PLM
    Description: The url of a docker image that contains the  application process that will handle the traffic for this service
  BackEndECRRepositoryName:
    Type: String
    Default: nginx
    Description: ECR repository Name that you need to create for  images 
  BackEndContainerPort:
    Type: Number
    Default: '8084'
    # Default: '80'
    Description: What port number the application inside the docker container is binding to
  BackEndContainerCpu:
    Type: Number
    Default: 992
    # Default: 1024    
    Description: How much CPU to give the container. 1024 is 1 CPU
  BackEndContainerMemory:
    Type: Number
    Default: 887
    # Default: 4096
    Description: How much memory in megabytes to give the 
  BackEndDesiredCount:
    Type: Number
    Default: 0
    Description: How many copies of the service task to run

# ALB Parameters 
  Path:
    Type: String
    Default: "*"
    Description: A path on the load balancer that this service should be connected to. Use * to send all load balancer traffic to this service.
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer. This only applies if your have multiple services which have been assigned to different paths on the load balancer.
  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the service's containers if the code within needs to access other AWS resources like S3 buckets, DynamoDB tables, etc

  HostedZoneId:
    Description: HostedZone ID
    Type: String
    Default: 'Z38JIISUVMYB2F'
  HostedZoneName:
    Description: HostedZone Name
    Type: String
    Default: 'dubaria.myinstance.com'
  PLMPublicLoadBalancerSubDomainNameWithDot:
    Description: 'Name that is used to create the DNS entry with trailing dot, e.g. ${SubDomainNameWithDot}${HostedZoneName}. Leave blank for naked (or apex and bare) domain. Requires ParentZoneStack parameter!'
    Type: String
    Default: '.'

# DomainBackEndPrivateServiceDiscoveryNamespace
  DomainBackEndPrivateServiceDiscoveryNamespace:
    Type: String
    Default: BackEnd
    Description: The name of the namespace. Services are prepended, for example user.service.production

# ASG / AutoScaling Parameters
  KeyPair:
    Description: Name of key pair to use for SSH access to the instances
    Type: 'AWS::EC2::KeyPair::KeyName'
    ConstraintDescription: Key pair must already exist in the region of the stack creation
    Default: dd-us-west-2
  InstanceType:
    Description: Type of EC2 instance to use
    Type: String
    AllowedValues:
      - t2.micro
    ConstraintDescription: Must be a size from t2 instance families
    Default: t2.micro

Mappings:
  InstanceArchMap:
    t2.micro:
      Arch: X8664
  RegionAmiMap:
    us-west-2:
      # aws ssm get-parameters --names /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id --region us-west-2 --query Parameters[].Value --output text
      X8664: ami-0a4cbf3bd47ef1bc9


Conditions:
  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]

Resources:
# ECS Resources
  PLMEcsCluster:
    Type: AWS::ECS::Cluster

  # Public load balancer, hosted in public subnets that is accessible to the public, and is intended to route traffic to one or more public facing services. This is used for accepting traffic from the public internet and directing it to public facing microservices
  PLMPublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access to ALB from anywhere on the internet to FrontEnd ECS Service 
          - CidrIp: 0.0.0.0/0
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref FrontEndContainerPort
            ToPort: !Ref FrontEndContainerPort
            Description: Allow access to ALB from anywhere on the internet to FrontEnd ECS Service
          # Allow access to ALB from anywhere on the internet to BackEnd ECS Service
          - CidrIp: 0.0.0.0/0
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndContainerPort
            ToPort: !Ref BackEndContainerPort
            Description: Allow access to ALB from anywhere on the internet to BackEnd ECS Service

  PLMPublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic from the internet can reach the load balancer directly via the internet gateway
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetOne
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetTwo
      SecurityGroups: [!Ref 'PLMPublicLoadBalancerSG']

  PLMPublicLoadBalancerRecordSet:
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: !Sub
        - '${PLMPublicLoadBalancerSubDomainNameWithDot}${HostedZoneName}'
        - SubDomainNameWithDot: !Ref PLMPublicLoadBalancerSubDomainNameWithDot
          HostedZoneName: !Ref HostedZoneName
      ResourceRecords:
        - !GetAtt 'PLMPublicLoadBalancer.DNSName'
      TTL: 300
      Type: CNAME

  BackEndPrivateServiceDiscoveryNamespace:
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
    Properties:
      Name: !Ref DomainBackEndPrivateServiceDiscoveryNamespace
      # Name: !Ref BackEndServiceName
      Vpc:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId

###################
# ASG resources
###################
  ECSInstanceProfileRole:
    Type: AWS::IAM::InstanceProfile
    Properties: 
      Roles: 
        - !Ref ECSInstanceRole
  ECSInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
  PLMEcsLaunchTemplate:
    Type: 'AWS::EC2::LaunchTemplate'
    Metadata:
      'AWS::CloudFormation::Init':
        configSets:
          base_setup:
            - cfn_hup
            - ecs_configure
            - install_pkgs
            - enable_sysstat
        cfn_hup:
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Join 
                - ''
                - - |
                    [main]
                  - stack=
                  - !Ref 'AWS::StackId'
                  - |+

                  - region=
                  - !Ref 'AWS::Region'
                  - |+

                  - |
                    interval=5
              mode: '000400'
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Join 
                - ''
                - - |
                    [cfn-auto-reloader-hook]
                  - |
                    triggers=post.update
                  - >
                    path=Resources.PLMEcsLaunchTemplate.Metadata.AWS::CloudFormation::Init
                  - 'action=/opt/aws/bin/cfn-init -v '
                  - '   --stack '
                  - !Ref 'AWS::StackName'
                  - '   --resource PLMEcsLaunchTemplate '
                  - '   --configsets base_setup '
                  - '   --region '
                  - !Ref 'AWS::Region'
                  - |+

                  - |
                    runas=root
              mode: '000400'
              owner: root
              group: root
          services:
            sysvinit:
              cfn-hup:
                enabled: 'true'
                ensureRunning: 'true'
                files:
                  - /etc/cfn/cfn-hup.conf
                  - /etc/cfn/hooks.d/cfn-auto-reloader.conf
        ecs_configure:
          files:
            /etc/ecs/ecs.config:
              content: !Join 
                - ''
                - - 'ECS_CLUSTER='
                  - !Ref 'PLMEcsCluster'
                  - |+

                  - >
                    ECS_AVAILABLE_LOGGING_DRIVERS=["json-file","awslogs","journald","logentries","syslog"]
                  - |
                    ECS_ENABLE_TASK_IAM_ROLE=true
                  - |
                    ECS_RESERVED_MEMORY=64
          services:
            sysvinit:
              cfn-hup:
                enabled: 'true'
                ensureRunning: 'true'
        install_pkgs:
          packages:
            yum:
              sysstat: []
              awscli: []
              bind-utils: []
        enable_sysstat:
          services:
            sysvinit:
              sysstat:
                enabled: 'true'
                ensureRunning: 'true'
    Properties:
      LaunchTemplateData:
        InstanceType: !Ref InstanceType
        ImageId: !FindInMap 
          - RegionAmiMap
          - !Ref 'AWS::Region'
          - !FindInMap 
            - InstanceArchMap
            - !Ref InstanceType
            - Arch
        KeyName: !Ref KeyPair
        SecurityGroupIds:
          # - !Ref ContainerSecurityGroup
          - !Ref FrontEndContainerSecurityGroup
          - !Ref BackEndContainerSecurityGroup
          # - !Ref NishitDushyantPLMEcsInstanceSecurityGroup
        IamInstanceProfile: 
          Name: !Ref ECSInstanceProfileRole
        UserData: !Base64 
          'Fn::Join':
            - ''
            - - |
                #!/bin/bash -xe
              - |
                yum update -y 
              - |
                yum install aws-cfn-bootstrap -y 
              - '/opt/aws/bin/cfn-init -v '
              - '   --stack '
              - !Ref 'AWS::StackId'
              - '   --resource PLMEcsLaunchTemplate '
              - '   --configsets base_setup '
              - '   --region '
              - !Ref 'AWS::Region'
              - |+

              - '/opt/aws/bin/cfn-signal -e $? '
              - '   --stack '
              - !Ref 'AWS::StackId'
              - '   --resource PLMEcsASG '
              - '   --region '
              - !Ref 'AWS::Region'
              - |+

        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${AWS::StackName}-PLMEcsASG'
  PLMEcsASG:
    Type: 'AWS::AutoScaling::AutoScalingGroup'
    DependsOn: PLMEcsCluster
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref PLMEcsLaunchTemplate
        Version: !GetAtt 
          - PLMEcsLaunchTemplate
          - LatestVersionNumber
      VPCZoneIdentifier:
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetOne
        - Fn::ImportValue: !Sub ${EnvironmentName}:PublicSubnetTwo
      MinSize: '3'
      MaxSize: '4'
      DesiredCapacity: '3'
      # NewInstancesProtectedFromScaleIn: true
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: '3'
        WaitOnResourceSignals: true
        PauseTime: PT5M
    CreationPolicy:
      ResourceSignal:
        Count: '1'
        Timeout: PT5M

  # PLMEcsInstanceSecurityGroup:
  #   Type: 'AWS::EC2::SecurityGroup'
  #   Properties:
  #     GroupDescription: Nishit Dushyant ECS Instance Security Group
  #     VpcId: {'Fn::ImportValue': !Sub '${EnvironmentName}:VpcId'}
  #     # SecurityGroupIngress:
  #     #   - Description: Allow traffic from [NISHITs Home to PLM ECS Instance]
  #     #     IpProtocol: tcp
  #     #     FromPort: 22
  #     #     ToPort: 22
  #     #     # CidrIp: !Join ['' , [{'Fn::ImportValue': !Sub '${EnvironmentName}:NatGatewayOneAttachment'} , '/32' ] ]
  #     #     # http://checkip.amazonaws.com/
  #     #     CidrIp: !Join ['' , ['71.150.221.250' , '/32' ] ]
  #     #   - Description: Allow traffic from [Dushyants Home to PLM ECS Instance]
  #     #     IpProtocol: tcp
  #     #     FromPort: 22
  #     #     ToPort: 22
  #     #     CidrIp: !Join ['' , ['74.141.7.117' , '/32' ] ]
  #     # Tags: 
  #     #   - Key: Name
  #     #     Value: DUSHYANT ECS Instance SSH


####################
# FrontEnd resources
####################
  # A security group for the containers we will run in Fargate. Rules are added to this security group based on what ingress you add for the cluster.
  FrontEndContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate FrontEnd containers
      # VpcId: !Ref 'VPC' Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      VpcId: 
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access ONLY from ALB 
          - SourceSecurityGroupId: !Ref PLMPublicLoadBalancerSG
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref FrontEndContainerPort
            ToPort: !Ref FrontEndContainerPort
            Description: !Sub Allow access ONLY from ALB:${PLMPublicLoadBalancer.LoadBalancerName} on Port:${FrontEndContainerPort}

  # This is a role which is used by the ECS tasks themselves.
  FrontEndECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        # - arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess
      Policies:
        - PolicyName: FrontEndECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Allow the ECS Tasks to download images from ECR
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'

                # Allow the ECS tasks to upload logs to CloudWatch
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
              Resource: '*'
  FrontEndECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        # - arn:aws:iam::aws:policy/AmazonS3FullAccess
      # Policies:
      #   - PolicyName: FrontEndECSTaskRolePolicy
      #     PolicyDocument:
      #       Statement:
      #       - Effect: Allow
      #         Action:
      #           # Allow the ECS Tasks to only Read from S3
      #           - 's3:Get*'
      #           - 's3:List*'
      #           # Allow the ECS tasks to get Secrets from SSM
      #           - 'ssm:Describe*'
      #           - 'ssm:Get*'
      #           - 'ssm:List*'
      #         Resource: '*'

  # A log group for storing the stdout logs from this service's containers
  FrontEndLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-ECSservice-${FrontEndServiceName}
      RetentionInDays: 7

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  FrontEndTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'FrontEndServiceName'
      Cpu: !Ref 'FrontEndContainerCpu'
      Memory: !Ref 'FrontEndContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !GetAtt 'FrontEndECSTaskExecutionRole.Arn'
      TaskRoleArn: !GetAtt 'FrontEndECSTaskRole.Arn'
      ContainerDefinitions:
        - Name: !Ref 'FrontEndServiceName'
          Cpu: !Ref 'FrontEndContainerCpu'
          Memory: !Ref 'FrontEndContainerMemory'
          # Image: !Ref 'FrontEndImageUrl'
          Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${FrontEndECRRepositoryName}:latest
          PortMappings:
            - ContainerPort: !Ref 'FrontEndContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-ECSservice-${FrontEndServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'FrontEndServiceName'

  # The service. The service is a resource which allows you to run multiple copies of a type of task, and gather up their logs and metrics, as well as monitor the number of running tasks and replace any that have crashed
  FrontEndECSService:
    Type: AWS::ECS::Service
    DependsOn: 
      - BackEndECSService
      - FrontEndLoadBalancerRule
    Properties:
      # ServiceName: !Ref 'FrontEndServiceName'
      Cluster: !Ref PLMEcsCluster
      LaunchType: FARGATE
      PlatformVersion: 1.4.0
      HealthCheckGracePeriodSeconds: '180'
      DeploymentConfiguration:
        MaximumPercent: '200'
        MinimumHealthyPercent: '100'
      DesiredCount: !Ref FrontEndDesiredCount
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups: 
            - !Ref FrontEndContainerSecurityGroup
          Subnets:
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetOne
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetTwo
      TaskDefinition: !Ref 'FrontEndTaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'FrontEndServiceName'
          ContainerPort: !Ref FrontEndContainerPort
          TargetGroupArn: !Ref 'FrontEndTargetGroup'

  # A target group. This is used for keeping track of all the tasks, and what IP addresses / port numbers they have. You can query it yourself, to use the addresses yourself, but most often this target group is just connected to an application load balancer, or network load balancer, so it can automatically distribute traffic across all the targets.
  FrontEndTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /currentFrontEnd
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 4
      TargetType: ip
      # Name: !Ref 'FrontEndServiceName'
      Port: !Ref 'FrontEndContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 10

  FrontEndPublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: PLMPublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'FrontEndTargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PLMPublicLoadBalancer'
      Port: !Ref FrontEndContainerPort
      Protocol: HTTP

  # Create a rule on the load balancer for routing traffic to the target group
  FrontEndLoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'FrontEndTargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn: !Ref FrontEndPublicLoadBalancerListener
      Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  FrontEndScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: FrontEndECSService
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId: !Join [ '/' , [ 'service' , !Ref 'PLMEcsCluster' , !GetAtt 'FrontEndECSService.Name' ] ] 
      MinCapacity: 1
      MaxCapacity: 2
      RoleARN: !Sub 'arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService'

  # Create Track scaling policies for the FrontEnd service
  FrontEndTargetTrackingScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: 
      - FrontEndLoadBalancerRule
      - FrontEndECSService
      - FrontEndScalableTarget
    Properties:
      PolicyName: !Join [ '/' , [ 'scale' , !Ref 'EnvironmentName' , !GetAtt 'FrontEndECSService.Name' ] ]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref FrontEndScalableTarget
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 100.00
        ScaleInCooldown: 120
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageMemoryUtilization

#################### 
# BackEnd resources
#################### 
  # A security group for the containers we will run in Fargate. Rules are added to this security group based on what ingress you add for the cluster.
  BackEndContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the Fargate BackEnd containers
      VpcId: 
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      SecurityGroupIngress:
          # Allow access ONLY from ALB from anywhere on the internet
          - SourceSecurityGroupId: !Ref PLMPublicLoadBalancerSG
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndContainerPort
            ToPort: !Ref BackEndContainerPort
            Description: !Sub Allow access ONLY from ALB:${PLMPublicLoadBalancer.LoadBalancerName} on BackEndContainerPort:${BackEndContainerPort}
          # Allow access ONLY from ALB from anywhere on the internet
          - SourceSecurityGroupId: !Ref FrontEndContainerSecurityGroup
            # IpProtocol: -1
            IpProtocol: tcp
            FromPort: !Ref BackEndContainerPort
            ToPort: !Ref BackEndContainerPort
            Description: !Sub Allow access ONLY from FrontEndContainerSecurityGroup:${FrontEndContainerSecurityGroup} on BackEndContainerPort:${BackEndContainerPort}

  # This is a role which is used by the ECS tasks themselves.
  BackEndECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
        # - arn:aws:iam::aws:policy/AmazonSSMReadOnlyAccess
      Policies:
        - PolicyName: BackEndAmazonECSTaskExecutionRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Allow the ECS Tasks to download images from ECR
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'

                # Allow the ECS tasks to upload logs to CloudWatch
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
              Resource: '*'

  BackEndECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
        # - arn:aws:iam::aws:policy/AmazonS3FullAccess
      # Policies:
      #   - PolicyName: FrontEndECSTaskRolePolicy
      #     PolicyDocument:
      #       Statement:
      #       - Effect: Allow
      #         Action:
      #           # Allow the ECS Tasks to only Read from S3
      #           - 's3:Get*'
      #           - 's3:List*'
      #           # Allow the ECS tasks to get Secrets from SSM
      #           - 'ssm:Describe*'
      #           - 'ssm:Get*'
      #           - 'ssm:List*'
      #         Resource: '*'


  # A log group for storing the stdout logs from this service's containers
  BackEndLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${EnvironmentName}-ECSservice-${BackEndServiceName}
      RetentionInDays: 7

  # The task definition. This is a simple metadata description of what container to run, and what resource requirements it has.
  BackEndTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'BackEndServiceName'
      Cpu: !Ref 'BackEndContainerCpu'
      Memory: !Ref 'BackEndContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'BackEndECSTaskRole.Arn'
      ExecutionRoleArn: !GetAtt 'BackEndECSTaskExecutionRole.Arn'
      ContainerDefinitions:
        - Name: !Ref 'BackEndServiceName'
          Cpu: !Ref 'BackEndContainerCpu'
          Memory: !Ref 'BackEndContainerMemory'
          # Image: !Ref 'BackEndImageUrl'
          Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${BackEndECRRepositoryName}:latest
          PortMappings:
            - ContainerPort: !Ref 'BackEndContainerPort'
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${EnvironmentName}-ECSservice-${BackEndServiceName}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: !Ref 'BackEndServiceName'

  # The service. The service is a resource which allows you to run multiple copies of a type of task, and gather up their logs and metrics, as well as monitor the number of running tasks and replace any that have crashed
  BackEndECSService:
    Type: AWS::ECS::Service
    DependsOn: BackEndLoadBalancerRule
    Properties:
      # ServiceName: !Ref 'BackEndServiceName'
      # Cluster:
      #   Fn::ImportValue: !Sub ${EnvironmentName}:PLMEcsCluster
      Cluster: !Ref PLMEcsCluster
      LaunchType: FARGATE
      PlatformVersion: 1.4.0
      HealthCheckGracePeriodSeconds: '180'
      DeploymentConfiguration:
        MaximumPercent: '200'
        MinimumHealthyPercent: '100'
      DesiredCount: !Ref BackEndDesiredCount
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups: 
            - !Ref BackEndContainerSecurityGroup
          Subnets:
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetOne
            - Fn::ImportValue: !Sub ${EnvironmentName}:PrivateSubnetTwo
      TaskDefinition: !Ref 'BackEndTaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'BackEndServiceName'
          ContainerPort: !Ref BackEndContainerPort
          TargetGroupArn: !Ref 'BackEndTargetGroup'
      ServiceRegistries:
        - RegistryArn: !GetAtt BackEndServiceDiscoveryService.Arn
          # ContainerPort: !Ref 'BackEndContainerPort'
          # ContainerName: !Ref 'BackEndServiceName'

  # Create a service discovery service in the private service namespace.
  BackEndServiceDiscoveryService:
    Type: AWS::ServiceDiscovery::Service
    Properties:
      Name: !Ref BackEndServiceName
      DnsConfig:
        DnsRecords: [{Type: A, TTL: "30"}]
        NamespaceId: !Ref BackEndPrivateServiceDiscoveryNamespace
      HealthCheckCustomConfig:
        FailureThreshold: 1

  # A target group. This is used for keeping track of all the tasks, and what IP addresses / port numbers they have. You can query it yourself, to use the addresses yourself, but most often this target group is just connected to an application load balancer, or network load balancer, so it can automatically divstribute traffic across all the targets.
  BackEndTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /BackEnd
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 4
      TargetType: ip
      # Name: !Ref 'BackEndServiceName'
      Port: !Ref 'BackEndContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub ${EnvironmentName}:VpcId
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 10

  BackEndPublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn: PLMPublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'BackEndTargetGroup'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PLMPublicLoadBalancer'
      Port: !Ref BackEndContainerPort
      Protocol: HTTP

  # Create a rule on the load balancer for routing traffic to the target group
  BackEndLoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'BackEndTargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      # ListenerArn:
      #   Fn::ImportValue: !Sub ${EnvironmentName}:PublicListener
      ListenerArn: !Ref BackEndPublicLoadBalancerListener
      Priority: !Ref 'Priority'

  # Enable autoscaling for this service
  BackEndScalableTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    DependsOn: BackEndECSService
    Properties:
      ServiceNamespace: 'ecs'
      ScalableDimension: 'ecs:service:DesiredCount'
      ResourceId: !Join [ '/' , [ 'service' , !Ref 'PLMEcsCluster' , !GetAtt 'BackEndECSService.Name' ] ] 
      MinCapacity: 1
      MaxCapacity: 2
      RoleARN: !Sub 'arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService'

  # Create Target Tracking scaling policies for the BackEnd service
  BackEndTargetTrackingScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    DependsOn: 
      - BackEndLoadBalancerRule
      - BackEndECSService
      - BackEndScalableTarget
    Properties:
      PolicyName: !Join [ '/' , [ 'scale' , !Ref 'EnvironmentName' , !GetAtt 'BackEndECSService.Name' ] ]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref BackEndScalableTarget
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 100.00
        ScaleInCooldown: 120
        ScaleOutCooldown: 60
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageMemoryUtilization


# These are the values output by the CloudFormation template. Be careful about changing any of them, because of them are exported with specific names so that the other task related CF templates can use them.
Outputs:
  PLMEcsCluster:
    Description: The name of the ECS cluster
    Value: !Ref 'PLMEcsCluster'
    Export:
      Name: !Sub ${EnvironmentName}:PLMEcsCluster

  # FrontEnd
  FrontEndECSTaskExecutionRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'FrontEndECSTaskExecutionRole.Arn'
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndECSTaskExecutionRole
  FrontEndContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref 'FrontEndContainerSecurityGroup'
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndContainerSecurityGroup
  FrontEndPublicLoadBalancerListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref FrontEndPublicLoadBalancerListener
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndPublicLoadBalancerListener
  FrontEndExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${FrontEndContainerPort}/currentFrontEnd
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndExternalUrl

  # BackEnd
  BackEndECSTaskExecutionRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'BackEndECSTaskExecutionRole.Arn'
    Export:
      Name: !Sub ${EnvironmentName}:BackEndECSTaskExecutionRole
  BackEndContainerSecurityGroup:
    Description: A security group used to allow Fargate containers to receive traffic
    Value: !Ref 'BackEndContainerSecurityGroup'
    Export:
      Name: !Sub ${EnvironmentName}:BackEndContainerSecurityGroup
  BackEndPublicLoadBalancerListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref BackEndPublicLoadBalancerListener
    Export:
      Name: !Sub ${EnvironmentName}:BackEndPublicLoadBalancerListener
  BackEndExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${BackEndContainerPort}/BackEnd
    Export:
      Name: !Sub ${EnvironmentName}:BackEndExternalUrl
  BackEndPrivateServiceDiscoveryNamespace:
    Description: The ID of the private service discovery namespace
    Value: !Ref BackEndPrivateServiceDiscoveryNamespace
    Export:
      Name: !Sub ${EnvironmentName}:BackEndPrivateServiceDiscoveryNamespace
  
  # FrontEndBackEnd
  FrontEndBackEndExternalUrl:
    Description: The url of the external load balancer
    # Value: !Sub http://${PublicLoadBalancer.DNSName}
    Value: !Sub http://${PLMPublicLoadBalancer.DNSName}:${FrontEndContainerPort}/currentFrontEnd/BackEnd
    Export:
      Name: !Sub ${EnvironmentName}:FrontEndBackEndExternalUrl
